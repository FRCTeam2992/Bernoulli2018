// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


package org.usfirst.frc2992.CubeBert2018;

import com.ctre.phoenix.motorcontrol.NeutralMode;
// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS
import com.ctre.phoenix.motorcontrol.can.WPI_TalonSRX;
import com.ctre.phoenix.motorcontrol.can.WPI_VictorSPX;

import edu.wpi.first.wpilibj.CounterBase.EncodingType;
import edu.wpi.first.wpilibj.DigitalInput;
import edu.wpi.first.wpilibj.Encoder;
import edu.wpi.first.wpilibj.PIDController;
import edu.wpi.first.wpilibj.PIDSourceType;
import edu.wpi.first.wpilibj.Solenoid;
import edu.wpi.first.wpilibj.SpeedController;
import edu.wpi.first.wpilibj.VictorSP;

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS
import edu.wpi.first.wpilibj.livewindow.LiveWindow;
import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;

/**
 * The RobotMap is a mapping from the ports sensors and actuators are wired into
 * to a variable name. This provides flexibility changing wiring, makes checking
 * the wiring easier and significantly reduces the number of magic numbers
 * floating around.
 */
public class RobotMap {
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    public static Solenoid driveTraindriveTrainSolenoid;
    public static WPI_TalonSRX driveTrainrFDriveMotor;
    public static WPI_TalonSRX driveTrainrBDriveMotor;
    public static WPI_TalonSRX driveTrainrMDriveMotor;
    public static WPI_TalonSRX driveTrainlFDriveMotor;
    public static WPI_TalonSRX driveTrainlMDriveMotor;
    public static WPI_TalonSRX driveTrainlBDriveMotor;
    public static Encoder driveTrainrightDriveEnc;
    public static Encoder driveTrainleftDriveEnc;
    
    public static SpeedController intakeleftIntakeMotor;
    public static SpeedController intakerightIntakeMotor;
    public static DigitalInput intakeleftIntakeSensor;
    public static DigitalInput intakerightIntakeSensor;
    public static Solenoid intakeintakeArmsSol;
    public static Solenoid intakeintakeDeploySol;
    
    public static WPI_TalonSRX liftClimberliftMotor;
    public static DigitalInput liftClimberliftBottomSensor;
    public static DigitalInput liftClimberliftTopSensor;
    public static Encoder liftClimberliftEnc;
    public static PIDController liftPID;
    public static WPI_TalonSRX liftClimberclimbMotor1;
    public static WPI_TalonSRX liftClimberclimbMotor2;
    public static Solenoid liftClimberrampLatchSol;
    public static Solenoid liftClimberrampDeploySol;
    public static Solenoid liftClimberrightScaleClampSol;
    public static Solenoid liftClimberleftScaleClampSol;
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS

    
    public static final int LiftEncCountsPerRev = 1024;//1024 encoder clicks per rev of the encoder
    public static final int LiftGearBoxRatio = 20;//20 rev of encoder per rev of the pulley
    public static final double LiftPulleyCirc = 1.125 * Math.PI;
    
    
    public static void init() {
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS
        driveTraindriveTrainSolenoid = new Solenoid(0, 0);
        LiveWindow.addActuator("DriveTrain", "driveTrainSolenoid", driveTraindriveTrainSolenoid);
        
        driveTrainrFDriveMotor = new WPI_TalonSRX(1);
        driveTrainrFDriveMotor.setNeutralMode(NeutralMode.Coast);
        
        driveTrainrBDriveMotor = new WPI_TalonSRX(3);
        driveTrainrBDriveMotor.setNeutralMode(NeutralMode.Coast);
        
        driveTrainrMDriveMotor = new WPI_TalonSRX(2);
        driveTrainrMDriveMotor.setNeutralMode(NeutralMode.Coast);
        
        driveTrainlFDriveMotor = new WPI_TalonSRX(4);
        driveTrainlFDriveMotor.setNeutralMode(NeutralMode.Coast);
        
        driveTrainlMDriveMotor = new WPI_TalonSRX(5);
        driveTrainlMDriveMotor.setNeutralMode(NeutralMode.Coast);
        
        driveTrainlBDriveMotor = new WPI_TalonSRX(6);
        driveTrainlBDriveMotor.setNeutralMode(NeutralMode.Coast);
        
        driveTrainrightDriveEnc = new Encoder(0, 1, false, EncodingType.k4X);
        LiveWindow.addSensor("DriveTrain", "rightDriveEnc", driveTrainrightDriveEnc);
        driveTrainrightDriveEnc.setDistancePerPulse(1.0);
        driveTrainrightDriveEnc.setPIDSourceType(PIDSourceType.kRate);
       
        driveTrainleftDriveEnc = new Encoder(2, 3, false, EncodingType.k4X);
        LiveWindow.addSensor("DriveTrain", "leftDriveEnc", driveTrainleftDriveEnc);
        driveTrainleftDriveEnc.setDistancePerPulse(1.0);
        driveTrainleftDriveEnc.setPIDSourceType(PIDSourceType.kRate);
        
        intakeleftIntakeMotor = new WPI_VictorSPX(6);
        LiveWindow.addActuator("Intake", "leftIntakeMotor", (VictorSP) intakeleftIntakeMotor);
        intakeleftIntakeMotor.setInverted(false);
        
        intakerightIntakeMotor = new WPI_VictorSPX(5);
        LiveWindow.addActuator("Intake", "rightIntakeMotor", (VictorSP) intakerightIntakeMotor);
        intakerightIntakeMotor.setInverted(true);
              
        intakeleftIntakeSensor = new DigitalInput(6);
        LiveWindow.addSensor("Intake", "leftIntakeSensor", intakeleftIntakeSensor);
        
        intakerightIntakeSensor = new DigitalInput(7);
        LiveWindow.addSensor("Intake", "rightIntakeSensor", intakerightIntakeSensor);
        
        intakeintakeArmsSol = new Solenoid(1, 1);
        LiveWindow.addActuator("Intake", "intakeArmsSol", intakeintakeArmsSol);
        
        intakeintakeDeploySol = new Solenoid(2, 1);
        LiveWindow.addActuator("Intake", "intakeDeploySol", intakeintakeDeploySol);
        
        liftClimberliftMotor = new WPI_TalonSRX(7);
        
        
        liftClimberliftBottomSensor = new DigitalInput(8);
        LiveWindow.addSensor("LiftClimber", "liftBottomSensor", liftClimberliftBottomSensor);
        
        liftClimberliftTopSensor = new DigitalInput(9);
        LiveWindow.addSensor("LiftClimber", "liftTopSensor", liftClimberliftTopSensor);
        
        liftClimberliftEnc = new Encoder(4, 5, false, EncodingType.k4X);
        LiveWindow.addSensor("LiftClimber", "liftEnc", liftClimberliftEnc); 
        
        // Encoder is geared 20:1 onto a 1.125 inch shaft -- 1024 pulses per revolution encoder
        //in inches.  finding dist of string per click
        liftClimberliftEnc.setDistancePerPulse(LiftPulleyCirc / (LiftGearBoxRatio * LiftEncCountsPerRev));
        liftClimberliftEnc.setPIDSourceType(PIDSourceType.kDisplacement);
        
        // PID Controller for cube lift
        liftPID = new PIDController(0.01, 0, 0, liftClimberliftEnc, liftClimberliftMotor);
        liftPID.setAbsoluteTolerance(0.5);		// Inches which is the output of scaled encoder
        LiveWindow.add(liftPID);
        
        liftClimberclimbMotor1 = new WPI_TalonSRX(8);
        liftClimberclimbMotor2 = new WPI_TalonSRX(9);
        LiveWindow.add(liftClimberclimbMotor1);
        LiveWindow.add(liftClimberclimbMotor2);
        liftClimberclimbMotor1.setNeutralMode(NeutralMode.Brake);
        liftClimberclimbMotor2.setNeutralMode(NeutralMode.Brake);
        
        liftClimberrampLatchSol = new Solenoid(5, 1);
        LiveWindow.addActuator("LiftClimber", "rampLatchSol", liftClimberrampLatchSol);
        
        liftClimberrampDeploySol = new Solenoid(6, 2);
        LiveWindow.addActuator("LiftClimber", "rampDeploySol", liftClimberrampDeploySol);
        
        liftClimberrightScaleClampSol = new Solenoid(3, 3);
        LiveWindow.addActuator("LiftClimber", "rightScaleClampSol", liftClimberrightScaleClampSol);
        
        liftClimberleftScaleClampSol = new Solenoid(4, 4);
        LiveWindow.addActuator("LiftClimber", "leftScaleClampSol", liftClimberleftScaleClampSol);
        

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS
        
        LiveWindow.add(driveTrainrFDriveMotor);
        LiveWindow.add(driveTrainrBDriveMotor);
        LiveWindow.add(driveTrainrMDriveMotor);
        LiveWindow.add(driveTrainlFDriveMotor);
        LiveWindow.add(driveTrainlMDriveMotor);
        LiveWindow.add(driveTrainlBDriveMotor);
        
        //invert the motors in robotmap to avoid confusion later
        driveTrainlFDriveMotor.setInverted(true);
        driveTrainlMDriveMotor.setInverted(true);
        driveTrainlBDriveMotor.setInverted(true);
    }
}
