// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


package org.usfirst.frc2992.CubeBert2018.subsystems;

import org.usfirst.frc2992.CubeBert2018.Robot;
import org.usfirst.frc2992.CubeBert2018.RobotMap;
import org.usfirst.frc2992.CubeBert2018.commands.*;

import com.ctre.phoenix.motorcontrol.ControlMode;
import com.ctre.phoenix.motorcontrol.NeutralMode;
import com.ctre.phoenix.motorcontrol.can.TalonSRX;
import org.usfirst.frc2992.CubeBert2018.mhJoystick;

import edu.wpi.first.wpilibj.command.Subsystem;
import edu.wpi.first.wpilibj.livewindow.LiveWindow;

// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS
import com.ctre.phoenix.motorcontrol.can.WPI_TalonSRX;
import com.kauailabs.navx.frc.AHRS;

import edu.wpi.first.wpilibj.CounterBase.EncodingType;
import edu.wpi.first.wpilibj.Encoder;
import edu.wpi.first.wpilibj.PIDController;
import edu.wpi.first.wpilibj.PIDSourceType;
import edu.wpi.first.wpilibj.Solenoid;

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS


/**
 *
 */
public class DriveTrain extends Subsystem {

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    private final Solenoid driveTrainSolenoid = RobotMap.driveTraindriveTrainSolenoid;
    //private final WPI_TalonSRX rFDriveMotor = RobotMap.driveTrainrFDriveMotor;
    private final WPI_TalonSRX rBDriveMotor = RobotMap.driveTrainrBDriveMotor;
    private final WPI_TalonSRX rMDriveMotor = RobotMap.driveTrainrMDriveMotor;
    //private final WPI_TalonSRX lFDriveMotor = RobotMap.driveTrainlFDriveMotor;
    private final WPI_TalonSRX lMDriveMotor = RobotMap.driveTrainlMDriveMotor;
    private final WPI_TalonSRX lBDriveMotor = RobotMap.driveTrainlBDriveMotor;
    public final Encoder rightDriveEnc = RobotMap.driveTrainrightDriveEnc;
    public final Encoder leftDriveEnc = RobotMap.driveTrainleftDriveEnc;

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    
    public final AHRS navx = RobotMap.navx;
    
    public PIDController lDistPID, rDistPID;
    DrivePID lDistance, rDistance;
    

    //distance pid
    final double ldkp = .085	;
    final double ldki = 0;
    final double ldkd = .15;
    final double hdkp = .035;
    final double hdki = 0;
    final double hdkd = .15;
    
    //gyro pid
    double gkp = .01; 
    double gkd = .0;
    double gError = 0.0;
    
    RotatePID turn;
    public PIDController turnPID;
    
    //rotate pid
    final double rkp = .015;
    final double rki = .0;
    final double rkd = .03;

    @Override
    public void initDefaultCommand() {
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND

        setDefaultCommand(new driveSticks());

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND

        // Set the default command for a subsystem here.
        // setDefaultCommand(new MySpecialCommand());
    }
    
    public DriveTrain(){
    	lDistance = new DrivePID(RobotMap.leftmotors);
    	lDistPID = new PIDController(ldkp, ldki, ldkd,leftDriveEnc, lDistance);
    	lDistPID.setOutputRange(-0.8, 0.8);
    	//lDistPID.setInputRange(-321.0, 321.0);
    	//lDistPID.setPercentTolerance(5.0);
    	lDistPID.setAbsoluteTolerance(2.0);
    	lDistPID.setName("Left Dist PID");
    	LiveWindow.add(lDistPID);
    	
    	lDistPID.disable();


    	rDistance = new DrivePID(RobotMap.rightmotors);
    	rDistPID = new PIDController(ldkp, ldki, ldkd, rightDriveEnc, rDistance);
    	rDistPID.setOutputRange(-0.8, 0.8);
    	rDistPID.setAbsoluteTolerance(2.0);
    	//rDistPID.setInputRange(-321.0, 321.0);
    	//rDistPID.setPercentTolerance(5.0);
    	rDistPID.setName("Right Dist PID");
    	LiveWindow.add(rDistPID);
    	rDistPID.disable();

    	turn = new RotatePID(RobotMap.leftmotors, RobotMap.rightmotors);
    	turnPID = new PIDController(rkp, rki, rkd, navx, turn);//change to navx for real robot
    	turnPID.setOutputRange(-0.8, 0.8);
    	turnPID.setInputRange(-180.0, 180.0);
    	turnPID.setContinuous();
    	turnPID.setAbsoluteTolerance(10);
    	turnPID.setSubsystem("DriveTrain");
    	turnPID.setName("turnPID");
    	LiveWindow.add(turnPID);
    	turnPID.disable();
    	
    	for (WPI_TalonSRX motor : RobotMap.allmotors) {// for all motors in that array - run one time
    		//current limiting all motors
        	motor.configPeakCurrentLimit(55, 0);//most can go is 55
        	motor.configPeakCurrentDuration(200, 0);//if go more than 55 for longer than 200ms...
        	motor.configContinuousCurrentLimit(55, 0);//set the max current to 55
        	motor.enableCurrentLimit(true);// allows for limiting the current
        	//setting a voltage ramp for all motors  basically 48 volts/sec
        	motor.configOpenloopRamp(0.15, 0);// (seconds from 0-full volts, timeout in millisec do 0); 
    	}
    }
    
    public void SmartDriveDist(double distance) {
    	SmartDriveDist(distance, 0.8);
    }
    
    public void SmartDriveDist(double distance, double speed){//for pid- drive no gyro
    	turnPID.disable();
    	lDistPID.setOutputRange(-speed,  speed);
    	rDistPID.setOutputRange(-speed,  speed);
    	for (WPI_TalonSRX motor : RobotMap.allmotors) {
    		motor.setNeutralMode(NeutralMode.Brake);
    	}
    	if (distance > 50) {
    		// Long run so shift to high gear
    		highGear();
    		lDistPID.setPID(hdkp, hdki, hdkd);
    		rDistPID.setPID(hdkp, hdki, hdkd);
    	} else {
    		lowGear();
    		lDistPID.setPID(ldkp, ldki, ldkd);
    		rDistPID.setPID(ldkp, ldki, ldkd);
    	}
    	//drivelib.smartDrive(distance, 0, lDistPID, rDistPID);
    	//lDistPID.reset();
    	//rDistPID.reset();
    	lDistPID.setSetpoint(distance+leftDriveEnc.getDistance());
    	rDistPID.setSetpoint(distance+rightDriveEnc.getDistance());
    	lDistPID.enable();
    	rDistPID.enable();
    }

    public void SmartDriveGyro(double heading, double power){//for pid - drive w/gyro
    	power = Math.abs(power);
    	double gyroError = calcGyroError(heading);
    	double pGyro = gError - gyroError;
    	System.out.println("GyroError:  " + gyroError);
    	lDistPID.setOutputRange(-power - gkp*gyroError + gkd *pGyro, power - gkp*gyroError + gkd *pGyro);
    	rDistPID.setOutputRange(-power + gkp*gyroError - gkd *pGyro, power + gkp*gyroError - gkd *pGyro);
    	System.out.println("Left power:  " + (power-gkp*gyroError - gkd *pGyro));
    	System.out.println("Right power:  " + (power + gkp*gyroError + gkd *pGyro));
    	gError = gyroError;
    }
    
    public void SmartDriveRot(double degrees){//for pid- rotate
    	lDistPID.disable();
    	rDistPID.disable();
    	//drivelib.smartDrive(0, degrees, turnPID);
    	turnPID.setSetpoint(degrees);
    	turnPID.enable();
    }
    
    private double calcGyroError(double heading){//for pid- finding error (difference)
    	double error = 0;
    	error = scaleAngle(navx.getYaw() - heading);
    	if(Math.abs(error) >= 1){
    		return error;
    	} else {
    		return 0;
    	}
    }

    private double scaleAngle(double angle){//for pid- make sure turning shortest dist - think circle
    	while(angle > 180){
    		angle -= 360;
    	}
    	while(angle < -180){
    		angle += 360;
    	}
    	return angle;
    }

    public boolean driveDone(String type){//for pid to see if drive fwd or drive turn is finished
    	if(type == "dist"){
    		if(lDistPID.onTarget() || rDistPID.onTarget()){//&&
    			return true;
    		} else {
    			return false;
    		}
    	} else if(type == "rot"){
    		if(turnPID.onTarget()){
    			return true;
    		} else {
    			return false;
    		}
    	} else {
    		return true;
    	}
	}
    
    public void allStop() {
    	for (WPI_TalonSRX motor : RobotMap.allmotors) {
    		motor.set(0.0);
    	}
    	lDistPID.disable();
    	rDistPID.disable();
    	turnPID.disable();
    	
    }
    
    public void tankDrive(double left, double right) {
    	/*
    	double zRotation = (left-right)/2.0;
    	double xSpeed = right+left/2.0;
    	
    	zRotation /= 1.2;			// Slow down turn rate
    	
    	
    	double maxInput = Math.copySign(Math.max(Math.abs(xSpeed), Math.abs(zRotation)), xSpeed);

        if (xSpeed >= 0.0) {
          // First quadrant, else second quadrant
          if (zRotation >= 0.0) {
            left = maxInput;
            right = xSpeed - zRotation;
          } else {
            left = xSpeed + zRotation;
            right = maxInput;
          }
        } else {
          // Third quadrant, else fourth quadrant
          if (zRotation >= 0.0) {
            left = xSpeed + zRotation;
            right = maxInput;
          } else {
            left = maxInput;
            right = xSpeed - zRotation;
          }
        }
        */
    	
    	double lrAvg = (left+right)/2.0;
    	double lrDiff = Math.abs(left-right);
    	
    	// Dampen turns by pushing left and right powers slightly toward the average
    	
    	left = (left + 0.8 * left + 1.2 * lrAvg) / 3.0;
    	right = (right + 0.8 * right + 1.2 * lrAvg) / 3.0;
    	
    	
        right = Math.max(-1.0, Math.min(1.0,  right));
        left = Math.max(-1.0, Math.min(1.0,  left));
        
        
    	for(WPI_TalonSRX motor : RobotMap.leftmotors) {
    		motor.set(left);
    	}
    	for(WPI_TalonSRX motor : RobotMap.rightmotors) {
    		motor.set(right);
    	}

    
    }

    public void highGear() {
    	driveTrainSolenoid.set(true);
    }
    
    public void lowGear() {
    	driveTrainSolenoid.set(false);
    }
    
    @Override
    public void periodic() {
        // Put code here to be run every loop

    }

    // Put methods for controlling this subsystem
    // here. Call these from Commands.

}

